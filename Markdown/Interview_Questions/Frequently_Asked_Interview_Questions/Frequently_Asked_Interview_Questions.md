# 常问面试题

### 一、`SQL`的生命周期

- 应用服务器与数据服务器建立一个连接。
- 数据进程拿到请求的`sql`。
- 解析并生成执行计划，执行。
- 读取数据到内存并进行逻辑处理。
- 通过建立的连接`步骤一的连接`，发送到客户端。
- 关掉连接，释放资源。

<br>

<br>

### 二、事务的四大特性：`ACID`

- ##### 数据库支持事务操作要具备的四个特性：

  - 原子性`Atomicity`：事务包含的所有操作要么全部成功`必须完全运用到数据库`，要么全部回滚失败`不能对数据库有任何影响`。
  - 一致性`Consistency`：事务必须使数据库从一个一致性状态换到另一个一致性状态，也就是说一个事务执行前和执行后都必须处于一致性状态。
  - 隔离性`Isolation`：多个用户并发访问数据库时，单个事务的操作不能相互干扰，所以多个并发事务之间要相互隔离。
    - `MySQL`数据库提供的四种隔离级别：
      - `Serializable` (串行化)：可避免脏读、不可重复读、幻读的发生；
      - `Repeatable read` (可重复读)：可避免脏读、不可重复读的发生；
      - `Read committed` (读已提交)：可避免脏读的发生；
      - `Read uncommitted` (读未提交)：最低级别，任何情况都无法保证。
  - 持久性`Durability`：事务一旦被提交，对数据库的数据改变是永久性的，数据库系统遇到故障的情况下也不会丢失提交事务的操作。

<br>

- ##### 数据事务并发造成的问题：

  - 脏读：一个事务处理过程中读取了另一个未提交的事务中的数据。
  - 不可重复读：一个事务范围内多次查询却返回了不同的数据值，在查询间隔被另一个事务修改并提交了`读取了另一条已经提交的事务`。
  - 虚读（幻读）：幻读是事务非独立执行时发生的一种现象`读取了另一条已经提交的事务`。

<br>

<br>

### 三、`Redis`数据类型

- `String` `字符串、整数或者浮点数` 对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减操作。
- `List` `列表` 从两端压入或者弹出元素；对单个或者多个元素进行修剪，只保留一个范围内的元素。
- `Set` `无序集合` 添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素。
- `Zset` `有序集合` 添加、获取、删除元素；根据分值范围或者成员来获取元素；计算一个键的排名。
- `Hash` `包含键值对的无序散列表` 添加、获取、移除单个键值对获取所有键值对；检查某个键是否存在。

<br>

<br>

### 四、Redis的三种集群模式

- 主从模式
- 哨兵模式
- `Cluster`集群模式

<br>

<br>

### 五、`Strin`、`StringBuffer`与`StringBuilder`的区别

![](https://github.com/Dashan-IZ/Notes/raw/master/Images/Interview_Questions_Images/Frequently_Asked_Interview_Questions_Images/2021-08-20_190601.png)

- `String`可以空赋值，`StringBuffer`和`StringBuilder`不行，报错；
- 操作少量的数据用`String`；
- 多线程操作字符串缓冲区下操作大量数据`StringBuffer`；
- 单线程操作字符串缓冲区下操作大量数据`StringBuilder`。
  - 底层实现，`StringBuffer`比`StringBuilder`多了`Synchronized`修饰符。

<br>

<br>

### 六、在Java中如何跳出当前的多重嵌套循环

- 可以在外层循环语句前定义一个标号，然后在内层循环体的代码中使用带有标号的`break`语句，即可跳出外层循环

```java
public static void main(String[] args) {
        public static void method1 () {
            ok:
            for (int i = 0; i < 10; i++) {
                for (int j = 0; j < 10; j++) {
                    System.out.println("i=" + i + ",j=" + j);
                    if (j == 5) {
                        break ok;//跳到循环外的ok处，即终止整个循环
                    }
                }
            }
        }
    }
```

<br>

<br>

### 七、`int`和`Integer`有什么区别

- Java提供两种不同类型：
  - 基本数据类型：`boolean`，`char`，`byte`，`short`，`int`，`long`，`float`，`double`；
  - 封装类类型：`Boolean`，`Character`，`Byte`，`Short`，`Integer`，`Long`，`Float`，`Double`。
  - 引用数据类型：`数组`、`类`、`接口`。

- `Int`是`java`的原始数据类型，`Integer`是`java`为`int`提供的封装  `int的包装类就是Integer`。

```java
// 装箱
Integer a = 10;
// 拆箱
int b = a;
```

<br>

<br>

### 八、数组`Array`和列表`ArrayList`的区别

- ##### 不同点：
  - `Array是数组` `ArrayList是一个集合`
  - 存储内容比较：`Array`可以包含基本类型和对象类型，`ArrayList`却只能包含对象类型，`Array`数组在存放的时候必须是同种类型的元素，`ArrayList`就不一定了；
  - 空间大小比较：`Array`数组空间大小是固定的，需要提前确定合适的空间大小，`ArrayList`的空间是动态增长的，而且每次添加新的元素的时候都会检查内部数组的空间是否足够；
  - 方法上的比较：`ArrayList`方法比`Array`更多样化，支持迭代器操作
    - ArrayList提供的方法和特性：`addAll()`，`removeAll()`，`iterator()`...

- ##### 适用场景：

  - 数据长度不变时尽量使用`Array`；
  - 当长度不固定时使用`ArrayList`，如果需要频繁增加数据时，可预设`ArrayList`的长度来减少复制数组的损耗；
  - 需要对元素进行频繁的移动或删除，或者是处理超大量的数据时`ArrayList`效率很低，可以考虑选择`LinkedList`。

<br>

<br>

### 九、什么是值传递和引用传递

- 一般`java`内的传递都是值传递

- 值传递：值传递是对基本型变量而言的，传递的是一个变量的副本，改变副本不影响原变量；
- 引用传递：引用传递一般是对对象(引用)型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身，所以引用对象进行操作时会改变原对象。

<br>

<br>

### 十、`Lamda`表达式的优缺点

- 优点：
  - 简洁
  - 非常容易并行计算
  - 可能代表未来的编程趋势
- 缺点：
  - 若不用并行计算，很多时候计算速度没有比传统的`for`循环快
  - 不容易调试
  - 若其他程序员没有学过`lambda`表达式，代码不容易让其他语言的程序员看懂

<br>

<br>

### 八、`final`，`finally`与`finalize`的区别

- `final`为常量关键字，而`finally`为异常关键字，`finalize`为`object`自带方法名
  - `final`：
    - `final`在`Java`中代表不可改变的，可用来修饰`类`，`方法`，`变量`;
    - `final`修饰的变量必须在声明时赋值，且不能再改变。
  - `finally`：
    - `finally`关键字用在异常处理中，用于处理异常后的清理工作；
    - `finally`实际中一般用于关闭文件流，释放资源等操作。
  - `finalize()`：
    - `finalize()`是`Object`里面的一个方法，当一个堆空间中的对象没有被栈空间变量指向的时候，这个对象会等待被`java`回收；
    - 垃圾回收机器，也叫`GC`：
      - 当对象不再被程序所使用的时候，垃圾回收器将会将其回收
      - 垃圾回收是在后台运行的，我们无法命令垃圾回收器马上回收资源，但是我们可以告诉可以尽快回收资源`System.gc()`和`Runtime.getRuntime().gc()`
      - 垃圾回收器在回收某个对象的时候，首先会调用该对象的`finalize()`方法
      - `GC`主要针对堆内存

<br>

<br>

### 九、`Java`中的方法重写`Overriding`和方法重载`Overloading`

- ##### 方法重写`Overriding`：

  - 重写的方法的方法名、参数个数、参数的类型要和父类的方法必须完全相同，这样定义的方法称作子类重写的方法`重写`；
  - 重写的注意事项：
    1. 参数列表必须完全与被重写的方法完全相同
    2. 参数的返回值必须一致
    3. 访问权限不能比父类中被重写方法的访问权限低
    4. 声明为`final`的方法不能被重写
    5. 声明为`static`的方法也不能被重写，但是可以被再次声明
    6. 如果子类和父类是在同一个包，那么子类可以重写父类的所有的方法
    7. `private`，因为私有的都继承不了，那就重写不了
    8. 构造方法也不能被重写

- ##### 方法重载`overloading`：

  - 在一个类中，方法名相同、参数不同、返回值可以相同也可以不同。
    每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。
  - 重载的注意事项：
    1. 方法名必须相同
    2. 方法的参数必须不同
    3. 返回类型可以相同也可以不同
    4. 参数的个数不同
    5. 参数的个数相同，但是参数列表中对应的某个参数的类型不同

<br>

<br>

### 十、重载`Overload`和重写`Override`的区别

- ##### 重写`Override`：

  - `Override`是重写的一个方法，以实现不同的功能。一般是用于子类在继承父类时，重写`重新实现`父类中的方法；
  - 重写`覆盖`的规则：
    1. 重写方法的参数列表必须完全与被重写的方法的相同,否则不能称其为重写而是重载；
    2. 重写方法的访问修饰符一定要大于被重写方法的访问修饰符`public`>`protected`>`default`>`private`；
    3. 重写的方法的返回值必须和被重写的方法的返回一致；
    4. 重写的方法所抛出的异常必须和被重写方法的所抛出的异常一致，或者是其子类；
    5. 被重写的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行重写；
    6. 静态方法不能被重写为非静态的方法`会编译出错`。


![](https://github.com/Dashan-IZ/Notes/raw/master/Images/Interview_Questions_Images/Frequently_Asked_Interview_Questions_Images/2021-08-23_193127.png)

- ##### 重载`Overload`：

  - `Overload`是重载，一般是用于在一个类内实现若干重载的方法，这些方法的名称相同而参数形式不同；
  - 重载的规则：
    1. 在使用重载时只能通过相同的方法名、不同的参数形式实现。不同的参数类型可以是不同的参数类型，不同的参数个数，不同的参数顺序`参数类型必须不一样`；
    2. 不能通过访问权限、返回类型、抛出的异常进行重载；
    3. 方法的异常类型和数目不会对重载造成影响。

<br>

<br>

### 十一、`Java`是否支持多继承

Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是java中的接口可以间接实现多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）接口的多继承不存在父接口中有同名方法的问题，因为接口中都是抽象方法，没有具体实现，不存在冲突，但是如果定义了相同的常量，则不能使用，会提示不明确的变量，必须通过接口名显示调用）。

- `java`中的类是单继承的，不支持多继承；
  - 即一个类只有一个父类。
- `java`中的接口可以间接实现多继承，即一个子接口可以有多个父接口；
  - 接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能；
  - 接口的多继承不存在父接口中有同名方法的问题，因为接口中都是抽象方法，没有具体实现，不存在冲突，但是如果定义了相同的常量，则不能使用，会提示不明确的变量，必须通过接口名显示调用。

<br>

<br>

### 十二、`ArrayList`和`LinkedList`的区别

- `ArrayList`的实现是基于`数组`来实现的，`LinkedList`的基于`双向链表`来实现。这两个数据结构的逻辑关系是不一样，当然物理存储的方式也会是不一样；
- `LinkedList`比`ArrayList`更占内存，因为`LinkedList`的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素；
- 对于随机访问，`ArrayList`要优于`LinkedList`；
- 对于插入和删除操作，`LinkedList`优于`ArrayList`。

<br>

<br>

### 十三、`HashMap`和`Hashtable`的区别

- ##### 是否线程安全

  - `HashMap`不是线程安全的，`HashTable`是线程安全的；
    - 【`HashTable`内部的方法基本都使用了synchronized关键字修饰】
  - 注意：现在`HashTable`在我们的开发中很少很少使用。如果你要保证线程安全，推荐使用`ConcurrentHashMap`。

- ##### 效率

  - 因为线程安全的问题，HashMap要比HashTable的效率高一点。

- ##### 对于`Null Key`和`Null Value`的支持

  - `HashMap`中，`null`可以作为`key`，但是这样的`key`只能有一个；可以有一个或者多个键对应的`value`为`null`；
  - `HashTable`中不支持`key`为`null`，如果`put`使用`null`，那么就会抛出`NullPointerException`异常。

- ##### 初始容量和每次扩充容量的大小不同

  - `HashMap`创建的时候如果不指定容量大小，初始容量大小为`16`，之后每次扩充，容量变为原来的`2倍`；
  - `HashTable`创建的时候如果不指定容量大小，初始容量大小为`11`，之后每次扩充，容量会变为`2n + 1`；
  - `HashTable`创建时如果给定了容量初始值，那么`Hashtable`会直接使用你给定的大小。

- ##### 底层数据结构

  - `JDK1.8`以后的`HashMap`在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间；
  - `Hashtable`没有这样的机制。
